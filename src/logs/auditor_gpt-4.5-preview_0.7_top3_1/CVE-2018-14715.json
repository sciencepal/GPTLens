[
    {
        "function_name": "buyPack",
        "code": "function buyPack(uint256 packId) public payable returns (bool) { require( packs[packId].price > 0 ); require( msg.value >= packs[packId].price ); packs[packId].price=0; for(uint8 i=0;i<10;i++){ tokenIndexToOwner[packs[packId].tokens[i]]=msg.sender; _transfer(0, msg.sender, packs[packId].tokens[i]); } delete packs[packId]; BuyPack(msg.sender,packId,msg.value); }",
        "vulnerability": "Ether loss due to lack of refund mechanism",
        "reason": "This function allows users to buy packs by sending Ether. However, it does not refund the excess Ether if the user sends more than needed. Specifically, if msg.value > packs[packId].price, the excess funds are permanently locked in the contract, causing users to lose funds. Attackers (malicious actors or accidental users) can exploit this by sending incorrect amounts, resulting in significant Ether loss.",
        "file_name": "2018-14715.sol",
        "label": "Bad Randomness",
        "description": "The endCoinFlip function and throwSlammer function of the smart contract implementations for Cryptogs, an Ethereum game, generate random numbers with an old block's hash. Therefore, attackers can predict the random number and always win the game."
    },
    {
        "function_name": "withdraw",
        "code": "function withdraw(uint256 _amount) public onlyOwner returns (bool) { require(this.balance >= _amount); assert(owner.send(_amount)); return true; }",
        "vulnerability": "Use of deprecated 'send' method for Ether transfer",
        "reason": "The function uses 'owner.send(_amount)', a deprecated and insecure method of Ether transfer that forwards a fixed amount of gas (2300 gas). If the owner's address is a contract with a fallback function requiring more than 2300 gas, the send will fail, causing Ether withdrawal to fail permanently. Attackers could exploit this by forcing the withdrawal to fail consistently by setting the owner's address to a malicious contract, effectively locking the Ether in the contract.",
        "file_name": "2018-14715.sol",
        "label": "Bad Randomness",
        "description": "The endCoinFlip function and throwSlammer function of the smart contract implementations for Cryptogs, an Ethereum game, generate random numbers with an old block's hash. Therefore, attackers can predict the random number and always win the game."
    },
    {
        "function_name": "endCoinFlip",
        "code": "function endCoinFlip(bytes32 _stack, bytes32 _counterStack, bytes32 _reveal) public returns (bool) { require(stacks[_stack].owner==msg.sender); require(stackCounter[_counterStack]==_stack); require(counterOfStack[_stack]==_counterStack); require(mode[_stack]==2); require(uint32(block.number)>commitBlock[_stack]); if(keccak256(_reveal)!=commit[_stack]){ mode[_stack]=1; CoinFlipFail(_stack); return false; }else{ mode[_stack]=3; round[_stack]=1; bytes32 pseudoRandomHash = keccak256(_reveal,block.blockhash(commitBlock[_stack])); if(uint256(pseudoRandomHash)%2==0){ lastBlock[_stack]=uint32(block.number); lastActor[_stack]=stacks[_counterStack].owner; CoinFlipSuccess(_stack,stacks[_stack].owner,true); }else{ lastBlock[_stack]=uint32(block.number); lastActor[_stack]=stacks[_stack].owner; CoinFlipSuccess(_stack,stacks[_counterStack].owner,false); } return true; } }",
        "vulnerability": "Dependence on predictable randomness (blockhash)",
        "reason": "The pseudo-randomness generated by 'block.blockhash(commitBlock[_stack])' can be manipulated or predicted by miners who can influence block hashes. Miners or attackers with sufficient influence over mining operations could manipulate the outcome of the 'CoinFlip', giving them a consistent advantage and allowing them to unfairly win games repeatedly. This vulnerability can be exploited in practice, leading to severe financial losses for honest players.",
        "file_name": "2018-14715.sol",
        "label": "Bad Randomness",
        "description": "The endCoinFlip function and throwSlammer function of the smart contract implementations for Cryptogs, an Ethereum game, generate random numbers with an old block's hash. Therefore, attackers can predict the random number and always win the game."
    }
]