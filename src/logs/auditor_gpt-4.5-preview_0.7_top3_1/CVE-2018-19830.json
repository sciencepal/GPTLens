[
    {
        "function_name": "transfer",
        "code": "function transfer(address _to, uint _value) onlyPayloadSize(2 * 32) unFrozenAccount onlyTransferable { if (frozenAccount[_to]) { InvalidAccount(_to, \"The receiver account is frozen\"); } else { balances[msg.sender] = balances[msg.sender].sub(_value); balances[_to] = balances[_to].add(_value); Transfer(msg.sender, _to, _value); } }",
        "vulnerability": "Missing revert after InvalidAccount event when receiver is frozen",
        "reason": "In the transfer function, when the receiver address is frozen, the contract only emits an InvalidAccount event without reverting the transaction. This means the function execution continues normally and no state changes are reverted. Although no tokens are transferred, the function execution is successful and does not clearly indicate failure. Attackers or malicious users can mistakenly assume the transaction succeeded because it doesn't revert, potentially causing confusion or incorrect assumptions in external systems relying on transaction success status. Proper security practice demands reverting the transaction explicitly if critical preconditions (like frozen account check) fail.",
        "file_name": "2018-19830.sol",
        "label": "Access Control",
        "description": "The UBSexToken() function of a smart contract implementation for Business Alliance Financial Circle (BAFC), an tradable Ethereum ERC20 token, allows attackers to change the owner of the contract, because the function is public (by default) and does not check the caller's identity."
    },
    {
        "function_name": "transferFrom",
        "code": "function transferFrom(address _from, address _to, uint _value) onlyPayloadSize(3 * 32) unFrozenAccount onlyTransferable{ var _allowance = allowed[_from][msg.sender]; require(!frozenAccount[_from]&&!frozenAccount[_to]); balances[_to] = balances[_to].add(_value); balances[_from] = balances[_from].sub(_value); allowed[_from][msg.sender] = _allowance.sub(_value); Transfer(_from, _to, _value); }",
        "vulnerability": "Use of deprecated 'var' keyword potentially leading to unintended integer overflow/underflow",
        "reason": "The transferFrom function declares the variable '_allowance' using the deprecated 'var' keyword. The 'var' keyword infers the type and can lead to incorrect type inference or unintended behavior, especially in older Solidity versions like 0.4.24. If the inferred data type is incorrect or smaller than expected, arithmetic operations might overflow or underflow silently, allowing attackers to exploit the contract by manipulating allowance values and transferring tokens beyond approved limits. Explicitly defining the variable type (uint) would mitigate this issue and align with best security practices.",
        "file_name": "2018-19830.sol",
        "label": "Access Control",
        "description": "The UBSexToken() function of a smart contract implementation for Business Alliance Financial Circle (BAFC), an tradable Ethereum ERC20 token, allows attackers to change the owner of the contract, because the function is public (by default) and does not check the caller's identity."
    },
    {
        "function_name": "approve",
        "code": "function approve(address _spender, uint _value) unFrozenAccount { if ((_value != 0) && (allowed[msg.sender][_spender] != 0)) throw; allowed[msg.sender][_spender] = _value; Approval(msg.sender, _spender, _value); }",
        "vulnerability": "Lack of mitigation against the ERC20 approval race condition vulnerability",
        "reason": "The approve function implements a condition requiring allowance to be zero before setting a new allowance. This approach partially mitigates the ERC20 approval race condition, but still leaves it exploitable in real-world scenarios. An attacker can monitor transactions in the mempool and quickly front-run a token approval transaction by using the allowance before the legitimate user changes it to zero and updates it. Because the contract does not implement functions like increaseAllowance or decreaseAllowance, users must manually set allowances to zero and then set a new allowance value, which is cumbersome and vulnerable to front-running attacks. This vulnerability can lead to attackers repeatedly exploiting users' approvals to spend tokens unauthorizedly.",
        "file_name": "2018-19830.sol",
        "label": "Access Control",
        "description": "The UBSexToken() function of a smart contract implementation for Business Alliance Financial Circle (BAFC), an tradable Ethereum ERC20 token, allows attackers to change the owner of the contract, because the function is public (by default) and does not check the caller's identity."
    }
]