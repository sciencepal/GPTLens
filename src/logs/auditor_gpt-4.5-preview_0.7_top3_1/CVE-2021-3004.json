[
    {
        "function_name": "_transferTokens",
        "code": "function _transferTokens(address src, address dst, uint amount) internal { balances[src] -= amount; balances[dst] += amount; emit Transfer(src, dst, amount); if (pairs[src]) { uint _fee = amount * FEE / BASE; _transferTokens(dst, address(this), _fee); notifyFeeAmount(_fee); } }",
        "vulnerability": "Infinite recursive call leading to stack overflow",
        "reason": "The function _transferTokens checks if the source address (src) is a registered pair, and if it is, it transfers a fee from the destination address (dst) back to the contract itself. However, if dst is also a registered pair, the subsequent call to _transferTokens will again trigger the pairing check, creating an infinite recursive loop. Since there is no termination condition or limit, this will eventually lead to a stack overflow, causing the transaction to revert. An attacker could exploit this vulnerability by transferring tokens between pairs, effectively making certain operations unusable or causing denial of service.",
        "file_name": "2021-3004.sol",
        "label": "Wrong Logic",
        "description": "The _deposit function in the smart contract implementation for Stable Yield Credit (yCREDIT), an Ethereum token, has certain incorrect calculations. An attacker can obtain more yCREDIT tokens than they should."
    },
    {
        "function_name": "_withdraw",
        "code": "function _withdraw(IERC20 token, uint amount) internal { uint _credit = collateralCredit[msg.sender][address(token)]; uint _collateral = collateral[msg.sender][address(token)]; if (_credit < amount) { amount = _credit; } uint _burned = _collateral * amount / _credit; address _pair = FACTORY.getPair(address(token), address(this)); IERC20(_pair).safeTransfer(_pair, _burned); (uint _amount0, uint _amount1) = ISushiswapV2Pair(_pair).burn(msg.sender); (address _token0,) = SushiswapV2Library.sortTokens(address(token), address(this)); (uint _amountA, uint _amountB) = address(token) == _token0 ? (_amount0, _amount1) : (_amount1, _amount0); collateralCredit[msg.sender][address(token)] -= amount; collateral[msg.sender][address(token)] -= _burned; _burn(msg.sender, _amountB+amount); emit Withdraw(msg.sender, address(token), amount, _amountB, _amountA); }",
        "vulnerability": "Unsafe arithmetic and division by zero causing withdrawal denial",
        "reason": "The arithmetic operation '_collateral * amount / _credit' can lead to division by zero if the '_credit' is zero. The current implementation does not verify if '_credit' is greater than zero, and it assumes implicitly that '_credit' is always non-zero. If an attacker or even a regular user calls the withdraw function when '_credit' becomes zero, this will result in a division by zero error, causing the transaction to revert, effectively trapping funds and preventing legitimate withdrawals.",
        "file_name": "2021-3004.sol",
        "label": "Wrong Logic",
        "description": "The _deposit function in the smart contract implementation for Stable Yield Credit (yCREDIT), an Ethereum token, has certain incorrect calculations. An attacker can obtain more yCREDIT tokens than they should."
    },
    {
        "function_name": "_addLiquidity",
        "code": "function _addLiquidity( address tokenA, address tokenB, uint amountADesired, uint amountBDesired ) internal virtual returns (address pair, uint amountA, uint amountB) { pair = FACTORY.getPair(tokenA, tokenB); if (pair == address(0)) { pair = FACTORY.createPair(tokenA, tokenB); pairs[pair] = true; _markets.push(tokenA); } else if (!pairs[pair]) { pairs[pair] = true; _markets.push(tokenA); } (uint reserveA, uint reserveB) = SushiswapV2Library.getReserves(address(FACTORY), tokenA, tokenB); if (reserveA == 0 && reserveB == 0) { (amountA, amountB) = (amountADesired, amountBDesired); } else { uint amountBOptimal = SushiswapV2Library.quote(amountADesired, reserveA, reserveB); if (amountBOptimal <= amountBDesired) { (amountA, amountB) = (amountADesired, amountBOptimal); } else { uint amountAOptimal = SushiswapV2Library.quote(amountBDesired, reserveB, reserveA); assert(amountAOptimal <= amountADesired); (amountA, amountB) = (amountAOptimal, amountBDesired); } } }",
        "vulnerability": "Missing slippage protection allows liquidity manipulation and front-running",
        "reason": "The _addLiquidity function calculates optimal token amounts for liquidity using reserves and the provided amounts desired. However, there are no checks or parameters to protect against slippage. Without such protections, attackers can front-run liquidity provisioning transactions, manipulate reserve ratios, and force liquidity providers to accept unfavorable terms. This allows attackers to profit at the expense of liquidity providers, significantly affecting the economic fairness and stability of the protocol.",
        "file_name": "2021-3004.sol",
        "label": "Wrong Logic",
        "description": "The _deposit function in the smart contract implementation for Stable Yield Credit (yCREDIT), an Ethereum token, has certain incorrect calculations. An attacker can obtain more yCREDIT tokens than they should."
    }
]