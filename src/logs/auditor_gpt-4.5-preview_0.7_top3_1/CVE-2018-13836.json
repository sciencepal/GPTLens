[
    {
        "function_name": "withdrawFunds",
        "code": "function withdrawFunds(address _token) public returns (bool success) {\n    require(msg.sender == owner);\n    if (_token == address(0)) {\n        owner.transfer(this.balance);\n    } else {\n        Token ERC20 = Token(_token);\n        ERC20.transfer(owner, ERC20.balanceOf(this));\n    }\n    return true;\n}",
        "vulnerability": "Missing return value check of ERC20 token transfer",
        "reason": "The function calls ERC20.transfer(owner, ERC20.balanceOf(this)); without verifying the boolean return value. According to the ERC20 standard, transfer() returns true or false to indicate success or failure. Ignoring this return value could allow malicious or faulty ERC20 tokens to fail silently without the contract being aware, potentially resulting in loss of tokens. An attacker can exploit this by creating a malicious ERC20 token and sending it to this contract, causing unexpected behavior or token locking.",
        "file_name": "2018-13836.sol",
        "label": "Integer Overflow",
        "description": "An integer overflow vulnerability exists in the function multiTransfer of Rocket Coin (XRC), an Ethereum token smart contract. An attacker could use it to set any user's balance."
    },
    {
        "function_name": "multiTransfer",
        "code": "function multiTransfer(address[] _addresses, uint[] _amounts) public returns (bool success) {\n    require(_addresses.length <= 100 && _addresses.length == _amounts.length);\n    uint totalAmount;\n    for (uint a = 0; a < _amounts.length; a++) {\n        totalAmount += _amounts[a];\n    }\n    require(totalAmount > 0 && balances[msg.sender] >= totalAmount);\n    balances[msg.sender] -= totalAmount;\n    for (uint b = 0; b < _addresses.length; b++) {\n        if (_amounts[b] > 0) {\n            balances[_addresses[b]] += _amounts[b];\n            Transfer(msg.sender, _addresses[b], _amounts[b]);\n        }\n    }\n    return true;\n}",
        "vulnerability": "Possible denial of service due to gas exhaustion",
        "reason": "The multiTransfer function loops through user-provided arrays (_addresses and _amounts) to distribute tokens. Although a maximum size of 100 addresses is enforced, executing transfers to multiple addresses within a single transaction can exceed the Ethereum block gas limit, causing the transaction to fail consistently. An attacker or malicious user can exploit this by repeatedly calling multiTransfer with near-limit arrays, potentially resulting in denial of service or unintended behavior on the contract's functionality.",
        "file_name": "2018-13836.sol",
        "label": "Integer Overflow",
        "description": "An integer overflow vulnerability exists in the function multiTransfer of Rocket Coin (XRC), an Ethereum token smart contract. An attacker could use it to set any user's balance."
    },
    {
        "function_name": "approve",
        "code": "function approve(address _spender, uint256 _amount) public returns (bool success) {\n    allowed[msg.sender][_spender] = _amount;\n    Approval(msg.sender, _spender, _amount);\n    return true;\n}",
        "vulnerability": "ERC20 approve race condition vulnerability",
        "reason": "The approve function allows token holders to set allowance directly from one non-zero value to another without requiring the allowance to first be set to zero. This leads to a known ERC20 race condition vulnerability, where a spender can quickly spend the old allowance before the token holder updates to a new allowance value. An attacker can exploit this by observing transactions on the mempool and executing immediate transfers, causing token holders to unintentionally approve more funds than intended.",
        "file_name": "2018-13836.sol",
        "label": "Integer Overflow",
        "description": "An integer overflow vulnerability exists in the function multiTransfer of Rocket Coin (XRC), an Ethereum token smart contract. An attacker could use it to set any user's balance."
    }
]