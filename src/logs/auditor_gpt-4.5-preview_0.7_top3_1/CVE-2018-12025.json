[
    {
        "function_name": "transferFrom",
        "code": "function transferFrom(address from, address to, uint value) returns (bool success) {\n    if (frozenAccount[msg.sender]) return false;\n    if(balances[from] < value) return false;\n    if( allowed[from][msg.sender] >= value ) return false;\n    if(balances[to] + value < balances[to]) return false;\n    balances[from] -= value;\n    allowed[from][msg.sender] -= value;\n    balances[to] += value;\n    Transfer(from, to, value);\n    return true;\n}",
        "vulnerability": "Incorrect allowance check logic",
        "reason": "The condition 'if(allowed[from][msg.sender] >= value) return false;' is incorrect and inverted. It rejects transactions when the allowance is sufficient, and allows transactions only if the allowance is lower than the requested value, contradicting the intended functionality. An attacker or malicious user could exploit this logic to deny legitimate token transfers approved by users, effectively blocking or manipulating token transfers and approvals. To fix this vulnerability, the condition should be 'if(allowed[from][msg.sender] < value) return false;' which correctly checks and allows transfers only if the spender has sufficient allowance.",
        "file_name": "2018-12025.sol",
        "label": "Wrong Logic",
        "description": "The transferFrom function of a smart contract implementation for FuturXE (FXE), an Ethereum ERC20 token, allows attackers to accomplish an unauthorized transfer of digital assets because of a logic error. The developer messed up with the boolean judgment - if the input value is smaller than or equal to allowed value, the transfer session would stop execution by returning false. This makes no sense, because the transferFrom() function should require the transferring value to not exceed the allowed value in the first place. Suppose this function asks for the allowed value to be smaller than the input. Then, the attacker could easily ignore the allowance: after this condition, the `allowed[from][msg.sender] -= value;` would cause an underflow because the allowed part is smaller than the value. The attacker could transfer any amount of FuturXe tokens of any accounts to an appointed account (the `_to` address) because the allowed value is initialized to 0, and the attacker could bypass this restriction even without the victim's private key."
    },
    {
        "function_name": "mintToken",
        "code": "function mintToken(address target, uint256 mintedAmount) onlyOwner{\n    balances[target] += mintedAmount;\n    totalSupply += mintedAmount;\n    Transfer(0,owner,mintedAmount);\n    Transfer(owner,target,mintedAmount);\n}",
        "vulnerability": "Incorrect Transfer event emitted",
        "reason": "The mintToken function incorrectly emits two Transfer events: 'Transfer(0, owner, mintedAmount)' and 'Transfer(owner, target, mintedAmount)'. According to ERC-20 standards, minting tokens should emit only a single Transfer event from address(0) (zero address) directly to the recipient's address. Emitting Transfer events involving the owner as an intermediate can mislead off-chain tools and analytics platforms, causing incorrect balances to be displayed or calculated. An attacker or the owner could exploit this to obfuscate token creation and confuse users or automated systems monitoring token issuance. To fix this vulnerability, the Transfer event should be emitted as 'Transfer(0, target, mintedAmount);' only once, clearly indicating tokens were minted from the zero address.",
        "file_name": "2018-12025.sol",
        "label": "Wrong Logic",
        "description": "The transferFrom function of a smart contract implementation for FuturXE (FXE), an Ethereum ERC20 token, allows attackers to accomplish an unauthorized transfer of digital assets because of a logic error. The developer messed up with the boolean judgment - if the input value is smaller than or equal to allowed value, the transfer session would stop execution by returning false. This makes no sense, because the transferFrom() function should require the transferring value to not exceed the allowed value in the first place. Suppose this function asks for the allowed value to be smaller than the input. Then, the attacker could easily ignore the allowance: after this condition, the `allowed[from][msg.sender] -= value;` would cause an underflow because the allowed part is smaller than the value. The attacker could transfer any amount of FuturXe tokens of any accounts to an appointed account (the `_to` address) because the allowed value is initialized to 0, and the attacker could bypass this restriction even without the victim's private key."
    },
    {
        "function_name": "transferOwnership",
        "code": "function transferOwnership(address new_owner) onlyOwner {\n    owner = new_owner;\n}",
        "vulnerability": "Missing zero address check when transferring ownership",
        "reason": "In the transferOwnership function, the contract allows the current owner to transfer ownership to any address without checking if the new owner is valid or non-zero. If the ownership is mistakenly transferred to address(0), no one will be able to execute any owner-protected functions anymore (such as minting or freezing accounts), effectively locking critical functionalities permanently. An attacker or malicious actor could trick the owner or exploit weaknesses in off-chain procedures to set the owner address to zero, causing permanent loss of administrative control. To fix this vulnerability, the function should include a zero address check such as 'require(new_owner != address(0));' ensuring ownership can only be transferred to a valid, controlled address.",
        "file_name": "2018-12025.sol",
        "label": "Wrong Logic",
        "description": "The transferFrom function of a smart contract implementation for FuturXE (FXE), an Ethereum ERC20 token, allows attackers to accomplish an unauthorized transfer of digital assets because of a logic error. The developer messed up with the boolean judgment - if the input value is smaller than or equal to allowed value, the transfer session would stop execution by returning false. This makes no sense, because the transferFrom() function should require the transferring value to not exceed the allowed value in the first place. Suppose this function asks for the allowed value to be smaller than the input. Then, the attacker could easily ignore the allowance: after this condition, the `allowed[from][msg.sender] -= value;` would cause an underflow because the allowed part is smaller than the value. The attacker could transfer any amount of FuturXe tokens of any accounts to an appointed account (the `_to` address) because the allowed value is initialized to 0, and the attacker could bypass this restriction even without the victim's private key."
    }
]