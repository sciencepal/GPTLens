[
    {
        "function_name": "luckyBuy",
        "code": "function luckyBuy() private view returns(bool) { uint256 seed = uint256(keccak256(abi.encodePacked( (block.timestamp).add (block.difficulty).add ((uint256(keccak256(abi.encodePacked(block.coinbase)))) / (now)).add (block.gaslimit).add ((uint256(keccak256(abi.encodePacked(msg.sender)))) / (now)).add (block.number) ))); if((seed - ((seed / 1000) * 1000)) < luckybuyTracker_) return(true); else return(false); }",
        "vulnerability": "Weak randomness generation",
        "reason": "The luckyBuy function uses blockchain attributes (block.timestamp, block.difficulty, block.coinbase, block.gaslimit, block.number, and msg.sender) to generate a random number. These variables are public and predictable, allowing attackers (especially miners or sophisticated users) to predict or influence the outcome. In practice, attackers could exploit this predictability by timing their transactions or mining blocks to increase their chances of triggering the luckyBuy success condition. This can lead to unfair rewards distribution and financial loss for honest participants.",
        "file_name": "2018-17877.sol",
        "label": "Bad Randomness",
        "description": "A lottery smart contract implementation for Greedy 599, an Ethereum gambling game, generates a random value that is predictable via an external contract call. The developer used the extcodesize() function to prevent a malicious contract from being called, but the attacker can bypass it by writing the core code in the constructor of their exploit code. Therefore, it allows attackers to always win and get rewards."
    },
    {
        "function_name": "win",
        "code": "function win() public { require(now > RoundTime[Round] && RoundTime[Round] != 0); RoundLastGreedyMan[Round].transfer(RoundETH[Round]); emit winnerEvent(RoundLastGreedyMan[Round], RoundETH[Round], Round); Round++; }",
        "vulnerability": "Denial of Service due to unchecked transfer",
        "reason": "The win function transfers Ether directly to the address stored in RoundLastGreedyMan[Round] using the transfer method. If the recipient address is a malicious contract or a contract which reverts upon receiving Ether, the transfer will continuously fail and revert the transaction. Consequently, Round increments and future rounds become locked, causing a permanent denial of service scenario. Attackers can deliberately exploit this by purchasing hearts from malicious contracts, thus permanently locking the game logic.",
        "file_name": "2018-17877.sol",
        "label": "Bad Randomness",
        "description": "A lottery smart contract implementation for Greedy 599, an Ethereum gambling game, generates a random value that is predictable via an external contract call. The developer used the extcodesize() function to prevent a malicious contract from being called, but the attacker can bypass it by writing the core code in the constructor of their exploit code. Therefore, it allows attackers to always win and get rewards."
    },
    {
        "function_name": "withdraw",
        "code": "function withdraw(uint _round) public { uint _revenue = getMyRevenue(_round); uint _revenueRef = MyreferredRevenue[msg.sender]; RoundMyPayMask[_round][msg.sender] += _revenue; MyreferredRevenue[msg.sender] = 0; msg.sender.transfer(_revenue + _revenueRef); emit withdrawRefEvent( msg.sender, _revenue); emit withdrawEvent(msg.sender, _revenue, _round); }",
        "vulnerability": "Unchecked Ether transfer causing Denial of Service",
        "reason": "The withdraw function uses the transfer method to send Ether directly to the msg.sender. If the msg.sender is a malicious contract or a faulty contract that rejects receiving Ether, this transfer will fail, causing the entire withdraw action to revert. Since the withdraw function updates accounting variables (RoundMyPayMask and MyreferredRevenue) only after the transfer, any failed withdrawal will permanently lock the user's funds in the contract. This vulnerability allows attackers to deliberately lock their own funds, potentially affecting platform reputation or user satisfaction, and could be exploited by malicious users aiming to cause disruption.",
        "file_name": "2018-17877.sol",
        "label": "Bad Randomness",
        "description": "A lottery smart contract implementation for Greedy 599, an Ethereum gambling game, generates a random value that is predictable via an external contract call. The developer used the extcodesize() function to prevent a malicious contract from being called, but the attacker can bypass it by writing the core code in the constructor of their exploit code. Therefore, it allows attackers to always win and get rewards."
    }
]