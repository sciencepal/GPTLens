[
    {
        "function_name": "EAI_TokenERC20",
        "code": "function EAI_TokenERC20( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",
        "vulnerability": "Constructor naming mistake allows anyone to become token owner",
        "reason": "The function intended as the constructor is named 'EAI_TokenERC20', which does not match the contract name 'EAI_TokenERC'. In Solidity version 0.4.16, a constructor must exactly match the contract's name to be recognized as a constructor. Due to this mismatch, the function is treated as a normal public function, allowing any attacker to call it repeatedly. An attacker can exploit this to reset the totalSupply and assign all tokens to themselves, effectively stealing the entire token supply from legitimate holders.",
        "file_name": "2019-15079.sol",
        "label": "Typo Constructor",
        "description": "A typo exists in the constructor of a smart contract implementation for EAI through 2019-06-05, an Ethereum token. This vulnerability could be used by an attacker to acquire EAI tokens for free."
    },
    {
        "function_name": "transferFrom",
        "code": "function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) { require(_value <= allowance[_from][msg.sender]); allowance[_from][msg.sender] -= _value; _transfer(_from, _to, _value); return true; }",
        "vulnerability": "Missing allowance double-spend check (Race condition)",
        "reason": "The 'transferFrom' function allows a spender to transfer tokens on behalf of another user. However, it does not follow the recommended safe practice of first setting a spender's allowance to zero before updating it. Although it decreases the allowance after transfer, the lack of required allowance reset (approve pattern) opens up a potential race condition vulnerability. An attacker can exploit this by submitting multiple transactions simultaneously or rapidly, potentially bypassing intended allowance limits and spending more tokens than permitted by the token holder.",
        "file_name": "2019-15079.sol",
        "label": "Typo Constructor",
        "description": "A typo exists in the constructor of a smart contract implementation for EAI through 2019-06-05, an Ethereum token. This vulnerability could be used by an attacker to acquire EAI tokens for free."
    },
    {
        "function_name": "_transfer",
        "code": "function _transfer(address _from, address _to, uint _value) internal { require(_to != 0x0); require(balanceOf[_from] >= _value); require(balanceOf[_to] + _value >= balanceOf[_to]); uint previousBalances = balanceOf[_from] + balanceOf[_to]; balanceOf[_from] -= _value; balanceOf[_to] += _value; emit Transfer(_from, _to, _value); assert(balanceOf[_from] + balanceOf[_to] == previousBalances); }",
        "vulnerability": "Integer overflow vulnerability",
        "reason": "The check 'require(balanceOf[_to] + _value >= balanceOf[_to]);' is supposed to prevent integer overflow but in Solidity version 0.4.16, arithmetic operations are not protected from overflow by default. This check alone is insufficient to fully protect against arithmetic overflow scenarios because it does not explicitly handle large inputs. Attackers can exploit this by sending very large values which cause an overflow in balance computations, potentially manipulating balances to steal tokens or lock them irreversibly.",
        "file_name": "2019-15079.sol",
        "label": "Typo Constructor",
        "description": "A typo exists in the constructor of a smart contract implementation for EAI through 2019-06-05, an Ethereum token. This vulnerability could be used by an attacker to acquire EAI tokens for free."
    }
]