[
    {
        "function_name": "EAI_TokenERC20",
        "vulnerability": "Constructor naming mistake allows anyone to become token owner",
        "criticism": "The reasoning provided is accurate and correctly identifies a critical vulnerability. In Solidity version 0.4.16, constructors must exactly match the contract name. Due to the mismatch ('EAI_TokenERC20' vs 'EAI_TokenERC'), the intended constructor becomes a regular public function callable by anyone. This allows attackers to repeatedly call the function, resetting the totalSupply and assigning all tokens to themselves, effectively stealing tokens from legitimate holders. This vulnerability is severe, as it completely undermines token ownership and distribution logic. It is also highly profitable, as attackers can easily exploit it to gain control of all tokens.",
        "correctness": 9,
        "severity": 9,
        "profitability": 9,
        "reason": "The function intended as the constructor is named 'EAI_TokenERC20', which does not match the contract name 'EAI_TokenERC'. In Solidity version 0.4.16, a constructor must exactly match the contract's name to be recognized as a constructor. Due to this mismatch, the function is treated as a normal public function, allowing any attacker to call it repeatedly. An attacker can exploit this to reset the totalSupply and assign all tokens to themselves, effectively stealing the entire token supply from legitimate holders.",
        "code": "function EAI_TokenERC20( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",
        "label": "Typo Constructor",
        "file_name": "2019-15079.sol",
        "description": "A typo exists in the constructor of a smart contract implementation for EAI through 2019-06-05, an Ethereum token. This vulnerability could be used by an attacker to acquire EAI tokens for free.",
        "final_score": 9.0
    },
    {
        "function_name": "_transfer",
        "vulnerability": "Integer overflow vulnerability",
        "criticism": "The reasoning provided is partially correct but somewhat misleading. The check 'require(balanceOf[_to] + _value >= balanceOf[_to]);' is indeed intended to prevent integer overflow. However, in Solidity 0.4.16, arithmetic operations are not protected by default, and this check alone is insufficient if extremely large values are used. The reasoning correctly identifies that large inputs could potentially cause overflow, but it exaggerates the practical exploitability. In practice, the function also includes a balance check ('require(balanceOf[_from] >= _value);'), significantly limiting the attacker's ability to exploit this vulnerability. Thus, while the correctness of identifying a potential overflow is moderate, the severity and profitability are relatively low, as practical exploitation would require unrealistic conditions (such as extremely large token balances).",
        "correctness": 5,
        "severity": 3,
        "profitability": 2,
        "reason": "The check 'require(balanceOf[_to] + _value >= balanceOf[_to]);' is supposed to prevent integer overflow but in Solidity version 0.4.16, arithmetic operations are not protected from overflow by default. This check alone is insufficient to fully protect against arithmetic overflow scenarios because it does not explicitly handle large inputs. Attackers can exploit this by sending very large values which cause an overflow in balance computations, potentially manipulating balances to steal tokens or lock them irreversibly.",
        "code": "function _transfer(address _from, address _to, uint _value) internal { require(_to != 0x0); require(balanceOf[_from] >= _value); require(balanceOf[_to] + _value >= balanceOf[_to]); uint previousBalances = balanceOf[_from] + balanceOf[_to]; balanceOf[_from] -= _value; balanceOf[_to] += _value; emit Transfer(_from, _to, _value); assert(balanceOf[_from] + balanceOf[_to] == previousBalances); }",
        "label": "Typo Constructor",
        "file_name": "2019-15079.sol",
        "description": "A typo exists in the constructor of a smart contract implementation for EAI through 2019-06-05, an Ethereum token. This vulnerability could be used by an attacker to acquire EAI tokens for free.",
        "final_score": 3.75
    },
    {
        "function_name": "transferFrom",
        "vulnerability": "Missing allowance double-spend check (Race condition)",
        "criticism": "The reasoning provided is incorrect and misunderstands the allowance mechanism. The described vulnerability ('missing allowance double-spend check') is not applicable here. The function correctly decreases the allowance before transferring tokens, which is the recommended practice. The described 'approve pattern' (setting allowance to zero before updating) is relevant to the approve function, not transferFrom. The transferFrom function itself does not require allowance reset checks. Therefore, the reasoning is fundamentally flawed. The severity and profitability are negligible, as the described scenario is not exploitable in this context.",
        "correctness": 1,
        "severity": 0,
        "profitability": 0,
        "reason": "The 'transferFrom' function allows a spender to transfer tokens on behalf of another user. However, it does not follow the recommended safe practice of first setting a spender's allowance to zero before updating it. Although it decreases the allowance after transfer, the lack of required allowance reset (approve pattern) opens up a potential race condition vulnerability. An attacker can exploit this by submitting multiple transactions simultaneously or rapidly, potentially bypassing intended allowance limits and spending more tokens than permitted by the token holder.",
        "code": "function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) { require(_value <= allowance[_from][msg.sender]); allowance[_from][msg.sender] -= _value; _transfer(_from, _to, _value); return true; }",
        "label": "Typo Constructor",
        "file_name": "2019-15079.sol",
        "description": "A typo exists in the constructor of a smart contract implementation for EAI through 2019-06-05, an Ethereum token. This vulnerability could be used by an attacker to acquire EAI tokens for free.",
        "final_score": 0.5
    }
]