[
    {
        "function_name": "setOwner",
        "code": "function setOwner(address _owner) returns (bool success) { owner = _owner; return true; }",
        "vulnerability": "Missing access control",
        "reason": "The setOwner function lacks any access restriction, allowing anyone (including attackers) to call this function and set themselves as the owner. Ownership is critical as it controls contract's sensitive functions such as unlocking tokens and uploading balances. An attacker exploiting this vulnerability can claim ownership of the contract, enabling further malicious activities such as token manipulation or token locking/unlocking at will. This is a severe vulnerability with real-world exploitation risk.",
        "file_name": "2018-10705.sol",
        "label": "Access Control",
        "description": "The Owned smart contract implementation for Aurora DAO (AURA), an Ethereum ERC20 token, allows attackers to acquire contract ownership because the setOwner function is declared as public. An attacker can then conduct a lockBalances() denial of service attack."
    },
    {
        "function_name": "uploadBalances",
        "code": "function uploadBalances(address[] recipients, uint256[] balances) onlyOwner { require(!balancesUploaded); uint256 sum = 0; for (uint256 i = 0; i < recipients.length; i++) { balanceOf[recipients[i]] = safeAdd(balanceOf[recipients[i]], balances[i]); sum = safeAdd(sum, balances[i]); } balanceOf[owner] = safeSub(balanceOf[owner], sum); }",
        "vulnerability": "Unchecked array length causing DoS",
        "reason": "The uploadBalances function accepts arrays of addresses and balances with no length limitations. If the arrays are too large, the function can run out of gas due to exceeding gas limits, causing a denial of service. The owner will not be able to successfully upload balances, potentially locking the contract in an unusable state. Attackers can exploit this by submitting large arrays (directly or indirectly through compromised owner account), preventing legitimate users from updating balances or performing intended contract operations.",
        "file_name": "2018-10705.sol",
        "label": "Access Control",
        "description": "The Owned smart contract implementation for Aurora DAO (AURA), an Ethereum ERC20 token, allows attackers to acquire contract ownership because the setOwner function is declared as public. An attacker can then conduct a lockBalances() denial of service attack."
    },
    {
        "function_name": "approveAndCall",
        "code": "function approveAndCall(address _spender, uint256 _value, bytes _extraData) public returns (bool success) { tokenRecipient spender = tokenRecipient(_spender); if (approve(_spender, _value)) { spender.receiveApproval(msg.sender, _value, this, _extraData); return true; } }",
        "vulnerability": "Re-entrancy vulnerability due to external call",
        "reason": "The approveAndCall function makes an external call to the spender's contract via spender.receiveApproval(...) after calling approve. If the spender contract is malicious, it can re-enter and exploit potential re-entrancy vulnerabilities. Although the current approve function has a lock check, once tokens are unlocked, this external call could still be exploited if future code modifications or unexpected states occur. This issue is critical as it can allow attackers to execute multiple calls and manipulate contract state unexpectedly.",
        "file_name": "2018-10705.sol",
        "label": "Access Control",
        "description": "The Owned smart contract implementation for Aurora DAO (AURA), an Ethereum ERC20 token, allows attackers to acquire contract ownership because the setOwner function is declared as public. An attacker can then conduct a lockBalances() denial of service attack."
    }
]