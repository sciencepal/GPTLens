[
    {
        "function_name": "AddTicket",
        "code": "function AddTicket() public payable { require(msg.value == ticketPrice); require(numtickets < maxTickets); lastTicketTime = now; numtickets += 1; totalBounty += ticketPrice; bool success = numtickets == maxTickets; NewTicket(msg.sender, success); if(success) { PayWinner(msg.sender); } }",
        "vulnerability": "Re-entrancy attack",
        "reason": "The AddTicket function calls the PayWinner function, which in turn makes an external call to the winner's address. This operation can allow the contract to be re-entered before the state variables have been updated, allowing an attacker to potentially withdraw funds multiple times.",
        "file_name": "2018-15552.sol",
        "label": "Bad Randomness",
        "description": "The \"PayWinner\" function of a simplelottery smart contract implementation for The Ethereum Lottery, an Ethereum gambling game, generates a random value with publicly readable variable \"maxTickets\" (which is private, yet predictable and readable by the eth.getStorageAt function). Therefore, it allows attackers to always win and get rewards."
    },
    {
        "function_name": "PayWinner",
        "code": "function PayWinner( address winner ) private { require(numtickets == maxTickets); uint ownerTax = 6 * totalBounty / 100; uint winnerPrice = totalBounty - ownerTax; LottoComplete(msg.sender, lottoIndex, winnerPrice); lottoIndex += 1; numtickets = 0; totalBounty = 0; if(_direction == 0 && maxTickets < 20) maxTickets += 1; if(_direction == 1 && maxTickets > 10) maxTickets -= 1; if(_direction == 0 && maxTickets == 20) _direction = 1; if(_direction == 1 && maxTickets == 10) _direction = 0; worldOwner.transfer(ownerTax); winner.transfer(winnerPrice); }",
        "vulnerability": "Integer division rounding down",
        "reason": "The calculation of the ownerTax can result in rounding down due to integer division. This can lead to precision loss and the winner receiving less than the intended amount.",
        "file_name": "2018-15552.sol",
        "label": "Bad Randomness",
        "description": "The \"PayWinner\" function of a simplelottery smart contract implementation for The Ethereum Lottery, an Ethereum gambling game, generates a random value with publicly readable variable \"maxTickets\" (which is private, yet predictable and readable by the eth.getStorageAt function). Therefore, it allows attackers to always win and get rewards."
    },
    {
        "function_name": "withdraw",
        "code": "function withdraw() public { require(worldOwner == msg.sender); lottoIndex += 1; numtickets = 0; totalBounty = 0; worldOwner.transfer(this.balance); }",
        "vulnerability": "Potential for loss of funds",
        "reason": "The worldOwner can withdraw all funds from the contract at any time. This can result in a loss of funds for users who have purchased tickets but the lottery has not yet been drawn.",
        "file_name": "2018-15552.sol",
        "label": "Bad Randomness",
        "description": "The \"PayWinner\" function of a simplelottery smart contract implementation for The Ethereum Lottery, an Ethereum gambling game, generates a random value with publicly readable variable \"maxTickets\" (which is private, yet predictable and readable by the eth.getStorageAt function). Therefore, it allows attackers to always win and get rewards."
    }
]