[
    {
        "function_name": "transfer",
        "code": "function transfer(address to, uint value) returns (bool success) { if (frozenAccount[msg.sender]) return false; if(balances[msg.sender] < value) return false; if(balances[to] + value < balances[to]) return false; balances[msg.sender] -= value; balances[to] += value; Transfer(msg.sender, to, value); return true; }",
        "vulnerability": "Integer Underflow",
        "reason": "The transfer function does not handle the case where the sender's balance is less than the value to be transferred. Essentially, if the sender's balance is less than the value to be transferred, the balance of the sender would underflow, and the sender would end up with an extraordinarily high balance.",
        "file_name": "2018-12025.sol",
        "label": "Wrong Logic",
        "description": "The transferFrom function of a smart contract implementation for FuturXE (FXE), an Ethereum ERC20 token, allows attackers to accomplish an unauthorized transfer of digital assets because of a logic error. The developer messed up with the boolean judgment - if the input value is smaller than or equal to allowed value, the transfer session would stop execution by returning false. This makes no sense, because the transferFrom() function should require the transferring value to not exceed the allowed value in the first place. Suppose this function asks for the allowed value to be smaller than the input. Then, the attacker could easily ignore the allowance: after this condition, the `allowed[from][msg.sender] -= value;` would cause an underflow because the allowed part is smaller than the value. The attacker could transfer any amount of FuturXe tokens of any accounts to an appointed account (the `_to` address) because the allowed value is initialized to 0, and the attacker could bypass this restriction even without the victim's private key."
    },
    {
        "function_name": "transferFrom",
        "code": "function transferFrom(address from, address to, uint value) returns (bool success) { if (frozenAccount[msg.sender]) return false; if(balances[from] < value) return false; if( allowed[from][msg.sender] >= value ) return false; if(balances[to] + value < balances[to]) return false; balances[from] -= value; allowed[from][msg.sender] -= value; balances[to] += value; Transfer(from, to, value); return true; }",
        "vulnerability": "Integer Underflow",
        "reason": "Similar to the transfer function, the transferFrom function does not handle the case where the sender's balance or allowed value is less than the value to be transferred. This could result in the sender's balance or allowance underflowing and becoming extremely high.",
        "file_name": "2018-12025.sol",
        "label": "Wrong Logic",
        "description": "The transferFrom function of a smart contract implementation for FuturXE (FXE), an Ethereum ERC20 token, allows attackers to accomplish an unauthorized transfer of digital assets because of a logic error. The developer messed up with the boolean judgment - if the input value is smaller than or equal to allowed value, the transfer session would stop execution by returning false. This makes no sense, because the transferFrom() function should require the transferring value to not exceed the allowed value in the first place. Suppose this function asks for the allowed value to be smaller than the input. Then, the attacker could easily ignore the allowance: after this condition, the `allowed[from][msg.sender] -= value;` would cause an underflow because the allowed part is smaller than the value. The attacker could transfer any amount of FuturXe tokens of any accounts to an appointed account (the `_to` address) because the allowed value is initialized to 0, and the attacker could bypass this restriction even without the victim's private key."
    },
    {
        "function_name": "mintToken",
        "code": "function mintToken(address target, uint256 mintedAmount) onlyOwner{ balances[target] += mintedAmount; totalSupply += mintedAmount; Transfer(0,owner,mintedAmount); Transfer(owner,target,mintedAmount); }",
        "vulnerability": "Arbitrary Minting",
        "reason": "The mintToken function allows the contract owner to create an arbitrary amount of tokens and send them to any address. This could lead to an oversupply of tokens, devaluing existing tokens, and it could be used maliciously to grant an enormous number of tokens to an attacker's address.",
        "file_name": "2018-12025.sol",
        "label": "Wrong Logic",
        "description": "The transferFrom function of a smart contract implementation for FuturXE (FXE), an Ethereum ERC20 token, allows attackers to accomplish an unauthorized transfer of digital assets because of a logic error. The developer messed up with the boolean judgment - if the input value is smaller than or equal to allowed value, the transfer session would stop execution by returning false. This makes no sense, because the transferFrom() function should require the transferring value to not exceed the allowed value in the first place. Suppose this function asks for the allowed value to be smaller than the input. Then, the attacker could easily ignore the allowance: after this condition, the `allowed[from][msg.sender] -= value;` would cause an underflow because the allowed part is smaller than the value. The attacker could transfer any amount of FuturXe tokens of any accounts to an appointed account (the `_to` address) because the allowed value is initialized to 0, and the attacker could bypass this restriction even without the victim's private key."
    }
]